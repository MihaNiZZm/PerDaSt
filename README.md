# Persistent Data Structures

## 1. Выбранная тема и усложнения

**Тема:** Персистентные структуры данных (Persistent Data Structures)

**Состав команды:**
- **Сартаков Михаил Юрьевич**, гр. 25221
- **Назаров Антон Константинович**, гр. 25221

**Выбранные усложнения:**
- Обеспечить произвольную вложенность данных (по аналогии с динамическими языками), не отказываясь при этом полностью от типизации посредством generic/template.
- Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности (для вложенных структур).
- Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node.

---

## 2. Зоны ответственности

| Участник            | Ответственности                                                                         |
|---------------------|----------------------------------------------------------------------------------------|
| **Сартаков Михаил** | Реализация и покрытие тестами персистентного массива;                                   |
|                     | Реализация и покрытие тестами персистентного ассоциативного массива (мапы);            |
| **Назаров Антон**   | Автоматическая генерация документации на основе кодовой документации.                   |
|                     | Реализация и покрытие тестами персистентного двусвязного списка.                        |

---

## 3. Краткое теоретическое описание задачи и решения

### Теоретическое описание задачи

Персистентные (неизменяемые, immutable) структуры данных — это такие структуры, которые после любой модифицирующей операции возвращают новую версию, не изменяя исходную, тем самым храня все прошлые состояния. Это даёт возможность эффективно реализовать функции отмены/повтора (undo/redo), работать с ветвлениями истории, реализовать транзакционные механизмы и безопасную многопоточность.

Цель работы — реализовать библиотеку неизменяемых коллекций (массив, двусвязный список, ассоциативный массив) с поддержкой undo/redo и вложенности с типобезопасностью.

---

### Выбранные решения и сравнение с альтернативами

**Для массива** выбран алгоритм `path copying` на базе 32-арного дерева:
- Любая модификация (например, изменение элемента) приводит к копированию только пути до листа в дереве (O(log₃₂ n)), все остальные части делятся между версиями.
- Это обеспечивает гораздо лучшую эффективность по памяти и времени, чем fat-node (где каждая ячейка хранит историю всех своих изменений).
- Также 32-арная структура уменьшает глубину дерева и улучшает производительность по сравнению с бинарными аналогами.

**Для ассоциативного массива (мапы)** реализуется path copying на базе самобалансирующегося бинарного дерева поиска (AVL):
- Такой подход проще HAMT/CHAMP по реализации, обеспечивает гарантированную O(log n) скорость базовых операций и экономит память по сравнению с fat-node благодаря sharing-у неизменных поддеревьев.
- Path copying легко интегрируется с persistent-undo/redo.

**Для двусвязного списка** реализуется path copying:
- При любой модификации копируются только необходимые узлы и их связи, остальные участки списка делятся между версиями.

---

### Сравнение алгоритмов в табличной форме

#### Персистентный массив

| Алгоритм           | Доступ get/set | Память (на операцию) | Сложность реализации | Время add/remove | Поддержка undo/redo |
|--------------------|----------------|----------------------|---------------------|------------------|---------------------|
| **Fat-node**       | O(log v)       | O(v) на ячейку       | Очень просто        | O(v)             | Просто              |
| **Path copying<br> (32-арное дерево)** | O(log₃₂ n)        | O(log₃₂ n)          | Средняя          | O(log₃₂ n)          | Отлично             |

#### Ассоциативный массив (мапа)

| Алгоритм                         | Доступ get/set | Память (на операцию) | Сложность реализации | Время remove | Поддержка undo/redo |
|----------------------------------|----------------|----------------------|---------------------|--------------|---------------------|
| **Fat-node**                     | O(log v)       | O(v) на ключ         | Очень просто        | O(v)         | Просто              |
| **Path copying BST (AVL)**       | O(log n)       | O(log n)             | Средняя             | O(log n)     | Отлично             |
| HAMT (Hash Array Mapped Trie)    | O(log₃₂ n)     | O(log₃₂ n)           | Сложная             | O(log₃₂ n)   | Отлично             |

#### Двусвязный список

| Алгоритм           | Доступ к элементу | Память (на операцию) | Сложность реализации | Время вставки/удаления | Поддержка undo/redo |
|--------------------|-------------------|----------------------|---------------------|-----------------------|---------------------|
| **Fat-node**       | O(log v)          | O(v) на узел         | Просто              | O(v)                  | Просто              |
| **Path copying**   | O(n)              | O(k), k — количество изменённых узлов | Средняя  | O(k)                  | Отлично             |

_(v — количество версий для ячейки, n — размер структуры)_

---

### Почему выбраны именно эти подходы

Данные методы обеспечивают **лучший баланс** между:
- Эффективностью по памяти и скорости по сравнению с fat-node (где всегда хранят всю историю в каждом элементе/узле).
- Простотой реализации (по сравнению с индустриальными HAMT или сбалансированными B-деревьями).
- Универсальностью (поддержка вложенных immutable-структур и каскадных undo/redo).
- Легкостью сериализации, дебага, тестирования и автоматической документации.
- Такие структуры широко используют в реальных масштабируемых проектах (например: [Clojure](https://clojure.org/reference/data_structures), [Scala Collections](https://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html), [kotlinx.collections.immutable](https://github.com/Kotlin/kotlinx.collections.immutable)).

Кроме того, благодаря неизменяемости, они идеально подходят для реализации undo/redo (каждая версия — отдельная структура), многопоточных приложений и сложных вложенных коллекций, аналогично динамическим языкам, но с тем преимуществом, что сохраняется типобезопасность и высокий контроль за памятью.

---

